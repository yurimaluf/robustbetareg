#' Robust Beta Regression
#'
#' Fit robust beta regression models for rates and proportions via LSMLE, LMDPDE, SMLE and MDPDE using a parametrization with mean (depending through a link function on the covariates) and precision parameter (called phi).
#'
#' @usage robustbetareg(formula, data, alpha, type = c("LSMLE", "LMDPDE", "SMLE", "MDPDE"),
#' link=c("logit", "probit", "cloglog", "cauchit", "loglog"),
#' link.phi=NULL, control=robustbetareg.control(...), model = TRUE, ...)
#'
#' @param formula symbolic description of the model (of type y ~ x or y ~ x | z).
#' @param data arguments controlling formula.
#' @param alpha the tuning value within [0,1), for robust estimation. When alpha is equal to zero (\eqn{\alpha}=0) is equivalent to MLE. If this argument is supressed, the tuning parameter should be selected automaticaly through the data-driven algorithm proposed by Ribeiro and Ferrari (2022).
#' @param type character specification of the type of estimator. Currently, LSMLE (default), LMDPDE, SMLE and MDPDE.
#' @param link character specification of the link function in the mean model (mu). Currently, "logit", "probit", "cloglog", "cauchit", "loglog" are supported
#' @param link.phi character specification of the link function in the precision model (phi). Currently, "identity", "log", "sqrt" are supported. The default is "log" unless formula is of type y ~ x where the default is "identity"
#' @param control a list of control arguments specified via \code{\link[=robustbetareg.control]{robustbetareg.control}}.
#' @param model  logicals for \code{robustbetareg}. If TRUE the corresponding components of the fit (model frame, response, model matrix) are returned. For LSMLE.fit, LMDPDE.fit, SMLE.fit and MDPDE.fit \code{y} must be a numeric response vector within (0,1).
#' @param ... argument to be passed to \code{\link[=robustbetareg.control]{robustbetareg.control}}.
#'
#' @references \href{https://www.tandfonline.com/doi/abs/10.1080/02664760701834931}{Espinheira, P.L., Ferrari, S.L.P., and Cribari-Neto, F. (2008). On Beta Regression Residuals. Journal of Applied Statistics, 35(4), 407â€“419.}
#' @references \href{https://doi.org/10.1177/0962280217738142}{Ghosh, A. Robust inference under the beta regression model with application to health care studies. Statistical Methods in Medical Research, 28:271-888 (2019).}
#' @references \href{https://doi.org/10.48550/arXiv.2209.11315}{Maluf, Y. S., Ferrari, S. L., & Queiroz, F. F. (2022). Robust beta regression through the logit transformation. arXiv}
#' @references \href{https://doi.org/10.1007/s00362-022-01320-0}{Ribeiro, K. A. T. Ferrari, S. L. P. Robust estimation in beta regression via maximum Lq-likelihood. Statistical Papers (2022).}
#'
#' @seealso \code{\link[robustbetareg:robustbetareg.control]{robustbetareg.control}}
#'
#' @examples
#' \dontrun{
#' #Table 1
#' data("HIC", package = "robustbetareg")
#' hic <- robustbetareg(Percent_HIC ~ Urbanization + GDP_percapita | 1, data = HIC, type = "LMDPDE")
#' summary(hic)
#'
#' #Table 2
#' data("RiskManagerCost", package = "robustbetareg")
#' rmc <- robustbetareg(FIRMCOST ~ INDCOST + SIZELOG | INDCOST + SIZELOG, data = RiskManagerCost,
#' alpha = 0.04)
#' summary(rmc)}
#'
#' @return robustbetareg returns an object of class "\code{robustbetareg}" with a list of the following components:\tabular{ll}{
#'    \code{coefficients} \tab A numeric vector of parameter estimates, \cr
#'    \tab \cr
#'    \code{vcov} \tab the covariance matrix of all parameters in the model, \cr
#'    \tab \cr
#'    \code{converged} \tab  logical indicating successful convergence of \code{optim} call, \cr
#'    \tab \cr
#'    \code{fitted.values} \tab the vector of predicted values, \cr
#'    \tab \cr
#'    \code{start} \tab the starting values for the parameters estimator, \cr
#'    \tab \cr
#'    \code{weights} \tab the weights generated by robust estimator for each obs, \cr
#'    \tab \cr
#'    \code{Tuning} \tab the selected tuning parameter, \cr
#'    \tab \cr
#'    \code{residuals} \tab a vector of standardized weighted residual 2 (see Espinheira et al (2008)), \cr
#'    \tab \cr
#'    \code{n} \tab number of observations, \cr
#'    \tab \cr
#'    \code{link} \tab mean link function applied, \cr
#'    \tab \cr
#'    \code{link.phi} \tab precision link function applied, \cr
#'    \tab \cr
#'    \code{Optimal.Tuning} \tab logical indicating whether the auto selecting tuning algorithm was selected, \cr
#'    \tab \cr
#'    \code{pseudo.r.squared} \tab pseudo R-squared value (squared correlation of linear predictor and link-transformed response), \cr
#'    \tab \cr
#'    \code{control} \tab the control arguments passed to auto selecting tuning algorithm and \code{optim} call, \cr
#'    \tab \cr
#'    \code{std.error} \tab the standard error of all parameters, \cr
#'    \tab \cr
#'    \code{method} \tab estimator type, \cr
#'    \tab \cr
#'    \code{call} \tab the original function call, \cr
#'    \tab \cr
#'    \code{formula} \tab the original formula, \cr
#'    \tab \cr
#'    \code{model} \tab the full model frame, \cr
#'    \tab \cr
#'    \code{terms} \tab a list with elemetns "\code{mean}", "\code{precision}" and "\code{full}" including the terms  \cr
#'    \tab objects for the respective models,  \cr
#'    \tab \cr
#'    \code{y} \tab the response proportion vector, \cr
#'    \tab \cr
#'    \code{data} \tab the dataset used. \cr
#' }
#'
#' @import betareg
#' @importFrom stats as.formula
#' @importFrom stats model.frame
#' @importFrom stats model.response
#' @importFrom stats model.matrix
#' @importFrom stats terms
#' @importFrom stats delete.response
#'
#' @export
robustbetareg = function(formula,data,alpha,type=c("LSMLE","LMDPDE","SMLE","MDPDE"),link = c("logit", "probit", "cloglog", "cauchit", "loglog"),
                         link.phi = NULL,control=robustbetareg.control(...), model = TRUE,...)
{
  cl = match.call()
  type = match.arg(type)
  ocontrol=control
  if(missing(data)){data=environment(formula)}
  if(!missing(alpha)){control$alpha.optimal=FALSE}
  if(missing(alpha)){alpha=NULL}
  mf = match.call(expand.dots = FALSE)
  m = match(c("formula", "data"), names(mf), 0L)
  mf = mf[c(1L, m)]
  mf$drop.unused.levels = TRUE
  formula = Formula::as.Formula(formula)
  oformula = as.formula(formula)
  if(length(formula)[2L] < 2L) {
    formula = Formula::as.Formula(formula(formula), ~1)
    simple_formula = TRUE
  }else {
    if(length(formula)[2L] > 2L) {
      formula = Formula::Formula(formula(formula, rhs = 1:2))
      warning("formula must not have more than two RHS parts")
    }
    simple_formula <- FALSE
  }
  mf1=model.frame(formula,data=data)
  y=model.response(mf1)
  x=model.matrix(formula,data=mf1,rhs = 1L)
  z=model.matrix(formula,data=mf1,rhs = 2L)
  if(simple_formula){colnames(z)[1]="(Phi)"}

  mt = terms(formula, data = data)
  mtX = terms(formula, data = data, rhs = 1L)
  mtZ = delete.response(terms(formula, data = data, rhs = 2L))

  #Error Model Treatment
  if(length(y) < 1){stop("empty model")}
  if(!(min(y) > 0 & max(y) < 1)){stop("invalid dependent variable, all observations must be in (0, 1)")}
  if(!is.null(control$start) & (ncol(x)+ncol(z))!=length(control$start) ){stop("Invalid initial starting point")}
  if(!is.null(alpha)){if(alpha < 0 || alpha > 1){stop("invalid tuning constant, the value must be in [0, 1)")}}
  if(!is.null(link.phi)){if(link.phi=="identity" & !simple_formula){link.phi="log";warning("Non suitable precision link function, log link used instead")}}

  link = match.arg(link)
  if(is.null(link.phi))
  {
    link.phi = if(simple_formula){"identity"}
    else "log"
  }
  if(is.null(control$start))
  {
    est.mle=suppressWarnings(betareg(oformula,data,link=link,link.phi = link.phi))
    control$start=c(est.mle$coefficients$mean,est.mle$coefficients$precision)
  }
  if(type=="LMDPDE")
  {
    result=LMDPDE.fit(y,x,z,alpha=alpha,link=link,link.phi=link.phi,control=control)
  }
  if(type=="LSMLE")
  {
    result=LSMLE.fit(y,x,z,alpha=alpha,link=link,link.phi=link.phi,control=control)
  }
  if(type=="SMLE")
  {
    result=SMLE.fit(y,x,z,alpha=alpha,link=link,link.phi=link.phi,control=control)
  }
  if(type=="MDPDE")
  {
    result=MDPDE.fit(y,x,z,alpha=alpha,link=link,link.phi=link.phi,control=control)
  }

  result$y=y
  if(model){result$model=list(mean = x, precision = z)}
  result$terms=list(mean = mtX, precision = mtZ, full = mt)
  result$call = cl
  result$data = mf1
  result$formula=as.formula(formula)
  gc()
  return(result)
}


#' Control Parameter for Robust Beta Regression
#'
#' Several parameters that control fitting of robust beta regression models using \code{\link[=robustbetareg]{robustbetareg.}}
#'
#' @usage robustbetareg.control(start = NULL, alpha.optimal = TRUE,
#' tolerance = 1e-3, maxit = 5000, L = 0.02, M = 3, ...)
#'
#' @param start a numeric vector as an initial guess of parameter estimation.
#' @param alpha.optimal a logical value. If TRUE the tuning parameter should be selected automatic.
#' @param tolerance numeric tolerance for convergence.
#' @param maxit integer specifying the maxit argument of iterations used by the Newton-Raphson algorithm.
#' @param L a parameter of auto selecting algorithm of tuning parameter.
#' @param M a integer parameter value of auto selecting algorithm of tuning parameter.
#' @param ... currently not used.
#'
#' @details The arguments \code{L} and \code{M} set the parameters of the data-driven algorithm for selecting the \eqn{\alpha} tuning parameter of robust estimator. See Ribeiro and Ferrari (2022) for more details.
#'
#' @references \href{https://doi.org/10.1007/s00362-022-01320-0}{Ribeiro, K. A. T. Ferrari, S. L. P. Robust estimation in beta regression via maximum Lq -likelihood. Statistical Papers (2022).}
#'
#' @return A list with the arguments specified.
#'
#' @export
robustbetareg.control=function(start=NULL,alpha.optimal=TRUE,tolerance=1e-3,maxit=5000,L=0.02,M=3,...)
{
  UseMethod("robustbetareg.control")
}

#' @export
robustbetareg.control.default=function(start=NULL,alpha.optimal=TRUE,tolerance=1e-3,maxit=5000,L=0.02,M=3,...)
{
  result <- list(start=start,alpha.optimal=alpha.optimal,tolerance = tolerance, maxit = maxit, L=L, M=M)
  result <- c(result, list(...))
  return(result)
}


#' The EGB of the second type
#'
#' Density and random generation for the exponential generalized beta (EGB) of the second type.
#'
#' @param y_star,q vector of quantiles.
#' @param p vector of probabilities.
#' @param n number of observations.
#' @param mu mu parameter (\eqn{\mu\in(0,1)}).
#' @param phi phi parameter (\eqn{\phi>0}).
#' @param log a logical value. If TRUE return the log of density function.
#'
#' @details The EGB density function is \eqn{f_{\theta}(y^{\star};\mu,\phi)=B^{-1}(\mu\phi,(1-\mu)\phi) \exp\{-y^{\star}(1-\mu)\phi\}/ (1+\exp\{-y^{\star}\})^{\phi}}, with \eqn{\mu\in(0,1),\phi>0} and \eqn{y^{\star}\in R} where \eqn{E(y^{\star})=\psi(\mu\phi)-\psi((1-\mu)\phi)}, \eqn{Var(y^{\star})=\psi'(\mu\phi)+\psi'((1-\mu)\phi)} where \eqn{\psi} is the digamma function. See Kerman and McDonald (2015) for more details.
#'
#' @references \href{https://doi.org/10.1080/03610926.2013.844255}{Kerman, S. McDonald, J. B. Skewness-kurtosis bounds for EGB1, EGB2, and special cases. Communications in Statistics - Theory and Methods, 44:3857-3864 (2015).}
#'
#' @return \code{degb} gives the density, \code{pegb} gives the distribution function, \code{qegb} gives the quantile function, and \code{regb} generates random sample of EGB variables.
#'
#'@export
degb=function(y_star,mu,phi,log=FALSE)
{
  #options(warn = 2) #Convert warnings into errors
  if (any((-abs(2*mu-1)+1)<=0)){
    return(warning("'mu' parameter must be within unit interval"))
  }
  if (any(phi<=0)){
    return(warning("'phi' parameter must be a positive value"))
  }

  a0=mu*phi
  b0=(1-mu)*phi
  if(log==F){
    k=tryCatch(exp(-(lgamma(a0)+lgamma(b0)-lgamma(a0+b0)+b0*y_star+phi*Rmpfr::log1pexp(-y_star))),error=function(e){stop("Error")})
  }
  if(log==T){
    k=tryCatch(-(lgamma(a0)+lgamma(b0)-lgamma(a0+b0)+b0*y_star+phi*Rmpfr::log1pexp(-y_star)),error=function(e){stop("Error")})
  }
  return(k)
}

#' @rdname degb
#'
#' @importFrom stats pbeta
#'
#' @export
pegb=function(q,mu,phi)
{
  if (any((-abs(2*mu-1)+1)<=0)){
    return(warning("'mu' parameter must be within unit interval"))
  }
  if (any(phi<=0)){
    return(warning("'phi' parameter must be a positive value"))
  }
  return(pbeta((1+exp(-q))^(-1),mu*phi,(1-mu)*phi))
}


#' @rdname degb
#'
#' @importFrom stats qbeta
#'
#' @export
qegb=function(p,mu,phi)
{
  if (any((-abs(2*mu-1)+1)<=0)){
    return(warning("'mu' parameter must be within unit interval"))
  }
  if (any(phi<=0)){
    return(warning("'phi' parameter must be a positive value"))
  }
  q=qbeta(p,mu*phi,(1-mu)*phi)
  return(-log((1/q)-1))
}

#' @rdname degb
#'
#' @param n number of observations.
#'
#' @importFrom stats rbeta
#'
#'@export
regb=function(n,mu,phi)
{
  if (any((-abs(2*mu-1)+1)<=0)){
    return(warning("'mu' parameter must be within unit interval"))
  }
  if (any(phi<=0)){
    return(warning("'phi' parameter must be a positive value"))
  }
  h=rbeta(n,mu*phi,(1-mu)*phi)
  return(log(h)-log(1-h))
}

#' Simulated Envelope of Residuals
#'
#' Plot a Simulated Envelope of Robust Beta Residuals from robustbetareg Object Class.
#'
#' @usage plotenvelope(object, type = c("sweighted2", "pearson", "weighted", "sweighted",
#' "sweighted.gamma", "sweighted2.gamma", "combined", "combined.projection", "sweighted3"),
#' conf = 0.95, n.sim = 100, PrgBar = T, control = robustbetareg.control(...), ...)
#'
#' @param object Fitted model object of class \code{robustbetareg} (see \code{\link[robustbetareg:robustbetareg]{robustbetareg}}).
#' @param type character indicating type of residuals.
#' @param conf the confidence level of the envelopes required. The default is to find 95\% confidence envelopes.
#' @param n.sim the number of simulation sample. Deafault \code{n.sim=100}.
#' @param PrgBar a logical value. If TRUE the progress bar will be shown in the console.
#' @param control a list of control arguments specified via \code{\link[robustbetareg:robustbetareg.control]{robustbetareg.control}}.
#' @param ... other parameters to be passed through to plotting functions.
#'
#' @return Return a simulated envelope graphic.
#'
#' @references \href{https://www.tandfonline.com/doi/abs/10.1080/02664760701834931}{Espinheira, P.L., Ferrari, S.L.P., and Cribari-Neto, F. (2008). On Beta Regression Residuals. Journal of Applied Statistics, 35(4), 407â€“419.}
#' @references \href{https://onlinelibrary.wiley.com/doi/abs/10.1002/bimj.201600136}{Espinheira, P.L., Santos, E.G.and Cribari-Neto, F. (2017). On nonlinear beta regression residuals. Biometrical Journal, 59(3), 445-461.}
#
#' @seealso \code{\link[robustbetareg:robustbetareg]{robustbetareg}}, \code{\link[robustbetareg:robustbetareg.control]{robustbetareg.control}}, \code{\link[robustbetareg:residuals]{residuals.robustbetareg}}
#'
#' @examples
#' \dontrun{
#' get(data("HIC", package = "robustbetareg"))
#' hic <- robustbetareg(Percent_HIC ~ Urbanization + GDP_percapita | GDP_percapita,
#' data = HIC, alpha = 0.06)
#' plotenvelope(hic, n.sim = 500)
#'
#' get(data("RiskManagerCost", package = "robustbetareg"))
#' rmc <- robustbetareg(FIRMCOST ~ INDCOST + SIZELOG | INDCOST + SIZELOG, data = RiskManagerCost)
#' plotenvelope(rmc, conf = 0.90)}
#'
#' @export
plotenvelope=function(object,type=c("sweighted2","pearson","weighted","sweighted","sweighted.gamma","sweighted2.gamma","combined","combined.projection","sweighted3"),conf=0.95,n.sim=100,PrgBar=T,control=robustbetareg.control(...), ...)
{
  UseMethod("plotenvelope")
}

#' @export
plotenvelope.robustbetareg=function(object,type=c("sweighted2","pearson","weighted","sweighted","sweighted.gamma","sweighted2.gamma","combined","combined.projection","sweighted3"),conf=0.95,n.sim=100,PrgBar=T,control=robustbetareg.control(...), ...)
{
  if(missing(control)){control=robustbetareg.control(object)}
  type = match.arg(type)
  ylim.boolean=methods::hasArg(ylim)
  arg=list(...)
  limit=FALSE
  y.sim=ResEnvelop=NULL
  link=object$link
  link.phi=object$link.phi
  y=object$y
  x=as.matrix(object$model$mean)
  z=as.matrix(object$model$precision)
  n=length(object$fitted.values$mu.predict)
  a=object$fitted.values$mu.predict*object$fitted.values$phi.predict
  b=(1-object$fitted.values$mu.predict)*object$fitted.values$phi.predict
  residual=residuals(object,type=type)
  k=1
  if(PrgBar){pb = utils::txtProgressBar(min = 0, max = n.sim, style = 3)}
  while(k<=n.sim & !limit)
  {
    y.sim=pmax(pmin(sapply(seq(1,n,1),function(i) rbeta(1,a[i],b[i])),1-.Machine$double.eps),.Machine$double.eps)
    est.mle=betareg.fit(x,y,z,link=link,link.phi = link.phi)
    start=c(est.mle$coefficients$mean,est.mle$coefficients$precision)
    if(object$method=="LSMLE"){
      robustbetareg.sim=tryCatch(LSMLE.fit(y=y.sim,x=x,z=z,alpha=object$Tuning,link=link,link.phi=link.phi,start=start),error=function(e){robustbetareg.sim$converged<-FALSE; return(robustbetareg.sim)})
    }else if(object$method=="LMDPDE"){
      robustbetareg.sim=tryCatch(LMDPDE.fit(y=y.sim,x=x,z=z,alpha=object$Tuning,link=link,link.phi=link.phi,start=start),error=function(e){robustbetareg.sim$converged<-FALSE; return(robustbetareg.sim)})
    }else if(object$method=="SMLE"){
      robustbetareg.sim=tryCatch(SMLE.fit(y=y.sim,x=x,z=z,alpha=object$Tuning,link=link,link.phi=link.phi,start=start),error=function(e){robustbetareg.sim$converged<-FALSE; return(robustbetareg.sim)})
    }else{
      robustbetareg.sim=tryCatch(MDPDE.fit(y=y.sim,x=x,z=z,alpha=object$Tuning,link=link,link.phi=link.phi,start=start),error=function(e){robustbetareg.sim$converged<-FALSE; return(robustbetareg.sim)})
    }
    if(robustbetareg.sim$converged)
    {
      if(type=="sweighted2")
      {
        ResEnvelop=rbind(ResEnvelop,sort(robustbetareg.sim$residuals,decreasing = F))
      }else{

        robustbetareg.sim$y=y.sim
        robustbetareg.sim$model$mean=object$model$mean
        robustbetareg.sim$model$precision=object$model$precision
        ResEnvelop=rbind(ResEnvelop,sort(residuals(robustbetareg.sim,type=type),decreasing = F))
      }
      k=k+1
      # update progress bar
      if(PrgBar){utils::setTxtProgressBar(pb, k)}
    }
    if(k==(2*n.sim)){limit=T}
  }
  Envelope=apply(ResEnvelop,2,stats::quantile,c((1-conf)/2,0.5,1-(1-conf)/2))
  if(!ylim.boolean)
  {
    ylim <- range(Envelope[1,],Envelope[2,],Envelope[3,],residual)
    arg$ylim=ylim
  }
  graphics::par(mar=c(5.0,5.0,4.0,2.0),pch=16, cex=1.0, cex.lab=1.0, cex.axis=1.0, cex.main=1.5)
  #ARG=append(list(y=residual,main="Envelope Plot", xlab="Normal quantiles",ylab="Residuals"),arg)
  ARG=append(list(y=residual,main="", xlab="Normal quantiles",ylab="Residuals"),arg)
  do.call(stats::qqnorm,ARG)
  graphics::par(new=T)
  ARG=utils::modifyList(ARG,list(y=Envelope[1,],axes=F,main = "",xlab="",ylab="",type="l",lty=1,lwd=1.0))
  do.call(stats::qqnorm,ARG)
  graphics::par(new=T)
  ARG=utils::modifyList(ARG,list(y=Envelope[2,],lty=2))
  do.call(stats::qqnorm,ARG)
  graphics::par(new=T)
  ARG=utils::modifyList(ARG,list(y=Envelope[3,],lty=1))
  do.call(stats::qqnorm,ARG)
}


#' Robust Wald-type Tests
#'
#' Wald-type tests for both simple and composite hypothesis for independent but non-homogeneous observations, based on LSMLE, LMDPDE, SMLE and MDPDE estimators.
#'
#' @param object fitted model object of class \code{robustbetareg} (see \code{\link[robustbetareg:robustbetareg]{robustbetareg}}).
#' @param FUN the function representing the null hypothesis to be tested.
#' @param ... Further arguments to be passed.
#'
#' @references \href{https://www.tandfonline.com/doi/abs/10.1080/02664760701834931}{Basu, A., Ghosh, A., Martin, N. et al. Robust Wald-type tests for non-homogeneous observations based on the minimum density power divergence estimator. Metrika 81, 493â€“522 (2018)}
#' @references \href{https://doi.org/10.48550/arXiv.2209.11315}{Maluf, Y. S., Ferrari, S. L., & Queiroz, F. F. (2022). Robust beta regression through the logit transformation. arXiv}
#' @references \href{https://doi.org/10.1007/s00362-022-01320-0}{Ribeiro, K. A. T. Ferrari, S. L. P. Robust estimation in beta regression via maximum Lq-likelihood. Statistical Papers (2022).}
#'
#' @seealso \code{\link[robustbetareg:robustbetareg]{robustbetareg}}
#'
#' @examples
#' \dontrun{
#' set.seed(2022)
#' N <- 40 #Sample Size
#' beta.coef <- c(-1,-2) #Arbitrary Beta Coefficients
#' gamma.coef <- c(5) #Arbitrary Gamma Coefficient
#' X <- cbind(rep(1,N), x <- runif(N))
#' mu <- exp(X%*%beta.coef)/(1+exp(X%*%beta.coef)) #Inverse Logit Link Function
#' phi <- exp(gamma.coef) #Inverse Log Link Function
#' y <- rbeta(N, mu*phi, (1-mu)*phi)
#' y[26] <- rbeta(1,((1 + mu[26])/2)*phi,(1-((1 + mu[26])/2))*phi) #Contaminated data point
#' SimData <- as.data.frame(cbind(y,x))
#' colnames(SimData) <- c("y","x")
#' fit.mle <- robustbetareg(y ~ x | 1, data = SimData, alpha = 0) #Non-Robust Estimator
#' fit.lsmle <- robustbetareg(y ~ x | 1, data = SimData) #Robust Estimator
#' h0 <- function(theta,B){theta[1:2] - B} #Hiphothesis to be tested
#' waldtypetest(fit.mle, h0, B = beta.coef) #Testing beta.1=-1 and beta.2=-2
#' waldtypetest(fit.simdata, h0, B = beta.coef) #Testing beta.1=-1 and beta.2=-2}
#'
#' @importFrom stats pchisq
#'
#' @export
waldtypetest=function(object,FUN,...)
{
  UseMethod("waldtypetest")
}

#' @export
waldtypetest.robustbetareg=function(object,FUN,...)
{
  general=FALSE
  if(missing(FUN)){general=T}
  if(!object$converged){stop(paste("There is no convergence in the model",deparse(substitute(object))))}
  cl = match.call()
  n=length(object$fitted.values$mu.predict)
  V=object$vcov
  b=object$coefficient$mean
  g=object$coefficient$precision
  p=c(b,g)
  k1=length(b)
  k2=length(g)
  k3=length(p)
  if(general)
  {
    result.beta=result.gamma=NULL
    if(ncol(object$model$mean)>1)
    {
      #Beta
      result.beta=list()
      f.b=function(x){x[2:k1]}
      M=numDeriv::jacobian(f.b,p,...)
      m=f.b(p,...)
      r=length(m)
      if(Matrix::rankMatrix(M)[1]!=r)
      {
        stop("The Rank Matrix is not supported")
      }
      W_alpha=t(m)%*%solve(M%*%V%*%t(M))%*%(m)
      #Beta Register
      result.beta$W.alpha=as.numeric(W_alpha)
      result.beta$df=r
      result.beta$pValue=as.numeric(1-pchisq(W_alpha,df=r))
    }
    if(ncol(object$model$precision)>1)
    {
      #Gamma
      result.gamma=list()
      f.g=function(x){x[(k1+2):k3]}
      M=numDeriv::jacobian(f.g,p,...)
      m=f.g(p,...)
      r=length(m)
      if(Matrix::rankMatrix(M)[1]!=r){stop("The Rank Matrix is not supported")}
      W_alpha=t(m)%*%solve(M%*%V%*%t(M))%*%(m)
      #Gamma Register
      result.gamma$W.alpha=as.numeric(W_alpha)
      result.gamma$df=r
      result.gamma$pValue=as.numeric(1-pchisq(W_alpha,df=r))
    }
    result=list(beta.wald=result.beta,gamma.wald=result.gamma,general=general,msg=paste("Results based on",object$method))
  }else{
    result=list()
    #Hipothesis
    f=FUN
    M=numDeriv::jacobian(f,p,...)
    m=f(p,...)
    r=length(m)
    n=length(object$fitted.values$mu.predict)
    if(Matrix::rankMatrix(M)[1]!=r){stop("The Rank Matrix is not supported")}
    W_alpha=t(m)%*%solve(M%*%V%*%t(M))%*%(m)
    #Register
    result$W.alpha=as.numeric(W_alpha)
    result$df=r
    result$pValue=as.numeric(1-pchisq(W_alpha,df=r))
    result$general=general
    result$msg=paste("Results based on",object$method)

  }
  result$method=object$method
  class(result)="WaldTest_robustbetareg"
  return(result)
}


#' @export
residuals=function(object,type=c("sweighted2","pearson","weighted","sweighted","sweighted.gamma","sweighted2.gamma","combined","combined.projection","sweighted3"),...)
{
  UseMethod("residuals")
}

#' Residuals Method for robustbetareg Object
#'
#' Extract several types of residuals from  robust beta regression models: Pearson residuals (raw residuals scaled by square root of variance function)
#' and different kinds of weighted residuals suggested by Espinheira et al. (2008) and Espinheira et al. (2017).
#'
#' @usage residuals(object,
#' type = c("sweighted2", "pearson", "weighted", "sweighted", "sweighted.gamma",
#'  "sweighted2.gamma", "combined", "combined.projection", "sweighted3"), ...)
#'
#' @param object fitted model object of class \code{robustbetareg} (see \code{\link[robustbetareg:robustbetareg]{robustbetareg}}).
#' @param type character indicating type of residuals.
#' @param ... currently not used.
#'
#' @return \code{residuals} returns a vector of selected residuals type.
#'
#' @details The definitions of the first four residuals are provided in Espinheira et al. (2008):  Equation (2) for "\code{pearson}", Equation (6) for "\code{weighted}", Equation (7) for "\code{sweighted}", and Equation (8) for "\code{sweighted2}".
#' For the last four residuals the definitions are described in Espinheira et al. (2017): Last equation of Equation (7) and Equation (10) for "\code{sweighted.gamma}" and "\code{sweighted2.gamma}" respectively, Equation (9) for "\code{combined}", and Equation (11) for "\code{combined.projection}".
#'
#' @references \href{https://www.tandfonline.com/doi/abs/10.1080/02664760701834931}{Espinheira, P.L., Ferrari, S.L.P., and Cribari-Neto, F. (2008). On Beta Regression Residuals. Journal of Applied Statistics, 35(4), 407â€“419.}
#' @references \href{https://onlinelibrary.wiley.com/doi/abs/10.1002/bimj.201600136}{Espinheira, P.L., Santos, E.G.and Cribari-Neto, F. (2017). On nonlinear beta regression residuals. Biometrical Journal, 59(3), 445-461.}
#'
#' @seealso \code{\link[robustbetareg:robustbetareg]{robustbetareg}}
#'
#' @examples
#' \dontrun{
#' get(data("HIC", package = "robustbetareg"))
#' fit.hic <- robustbetareg(Percent_HIC ~ Urbanization + GDP_percapita | 1, data = HIC, alpha = 0.04)
#' res <- residuals(fit.hic, type = "sweighted2")
#' plot(res)
#' abline(h = 0)}
#'
#' @aliases residuals residuals .robustbetareg
#'
#' @method residuals robustbetareg
#'
#' @export
residuals.robustbetareg=function(object,type=c("sweighted2","pearson","weighted","sweighted","sweighted.gamma","sweighted2.gamma","combined","combined.projection","sweighted3"),...)
{
  type = match.arg(type)
  y=object$y
  x=object$model$mean
  z=object$model$precision
  linkobj=set.link(link.mu=object$link,link.phi=object$link.phi)
  mu.predict=object$fitted.values$mu.predict
  phi.predict=object$fitted.values$phi.predict
  switch(type,sweighted2={
    res=sweighted2_res(mu_hat=mu.predict,phi_hat=phi.predict,y=y,X=x,linkobj=linkobj)
  },
  sweighted={
    res=res=sweighted_res(mu_hat=mu.predict,phi_hat=phi.predict,y=y)
  },
  pearson={
    res=pearson_res(mu_hat=mu.predict,phi_hat=phi.predict,y=y)
  },
  weighted={
    res=weighted_res(mu_hat=mu.predict,phi_hat=phi.predict,y=y)
  },
  sweighted.gamma={
    res=sweighted.gamma_res(mu_hat=mu.predict,phi_hat=phi.predict,y=y)
  },
  sweighted2.gamma={
    res=sweighted2.gamma_res(mu_hat=mu.predict,phi_hat=phi.predict,y=y,Z=z,linkobj=linkobj)
  },
  combined={
    res=combined_res(mu_hat=mu.predict,phi_hat=phi.predict,y=y)
  },
  combined.projection={
    res=combined.projection_res(mu_hat=mu.predict,phi_hat=phi.predict,y=y,X=x,Z=z,linkobj=linkobj)
  },
  sweighted3={
    res=sweighted3_res(mu_hat=mu.predict,phi_hat=phi.predict,alpha=object$Tuning,y=y,X=x,linkobj=linkobj)
  },

  stop(gettextf("%s residual not recognised", sQuote(type)),domain = NA))

  return(res)
}


#' Prediction Methods for robustbetareg Objects Class
#'
#' Extract various types of predictions from beta regression models: either on the scale of responses in (0, 1) or the scale of the linear predictor, from robustbetareg object class.
#'
#'@usage predict(object, newdata = NULL,
#' type = c("response", "link", "precision", "variance", "quantile"), at = 0.5, ...)
#'
#' @param object Fitted model object of class \code{robustbetareg} (see \code{\link[robustbetareg:robustbetareg]{robustbetareg}}).
#' @param newdata optionally, a data frame in which to look for variables with which to predict. If omitted, the original observations are used.
#' @param type character indicating type of predictions: fitted means of response ("response"), corresponding linear predictor ("link"), fitted precision parameter phi ("precision"),
#' fitted variances of response ("variance"), or fitted quantile(s) of the response distribution ("quantile").
#' @param at numeric vector indicating the level(s) at which quantiles should be predicted (only if type = "quantile"), defaulting to the median at = 0.5.
#' @param ... currently not used.
#'
#' @return Return a vector of predicted values.
#'
#' @examples
#' \dontrun{
#' get(data("HIC", package = "robustbetareg"))
#' hic <- robustbetareg(Percent_HIC ~ Urbanization + GDP_percapita | 1, data = HIC, alpha = 0.04)
#' cbind(predict(hic, type = "response"), predict(hic, type = "quantile", at = c(0.25, 0.5, 0.75)))}
#'
#' @export
predict = function(object, newdata = NULL, type = c("response", "link", "precision", "variance", "quantile"), at = 0.5, ...)
{
  UseMethod("predict")
}

#' @export
predict.robustbetareg = function(object, newdata = NULL, type = c("response", "link", "precision", "variance", "quantile"), at = 0.5, ...)
{
  type <- match.arg(type)
  if (type == "quantile") {
    qfun <- function(at, mu, phi) {
      rval <- sapply(at, function(p) stats::qbeta(p, mu * phi, (1 - mu) * phi))
      if (length(at) > 1L) {
        if (NCOL(rval) == 1L)
          rval <- matrix(rval, ncol = length(at), dimnames = list(unique(names(rval)),NULL))
        colnames(rval) <- paste("q_", at, sep = "")
      }
      else {
        rval <- drop(rval)
      }
      rval
    }
  }
  if (missing(newdata)) {
    rval <- switch(type, response = {
      object$fitted.values$mu.predict
    }, link = {
      set.link(object$link,object$link.phi)$linkfun.mu$linkfun(object$fitted.values$mu.predict)
    }, precision = {
      object$fitted.values$phi.predict
    }, variance = {
      object$fitted.values$mu.predict*(1-object$fitted.values$mu.predict)/(1+object$fitted.values$phi.predict)
    }, quantile = {
      qfun(at, object$fitted.values$mu.predict, object$fitted.values$phi.predict)
    })
    return(rval)
  }else{
    newdata=tryCatch(as.data.frame(newdata),error=function(e){newdata})
    x=model.matrix(object$formula,data=newdata,rhs = 1L)
    z=model.matrix(object$formula,data=newdata,rhs = 2L)

    rval <- switch (type, response = {
      set.link(object$link,object$link.phi)$linkfun.mu$inv.link(x%*%object$coefficients$mean)
    }, link = {
      mu_predict=set.link(object$link,object$link.phi)$linkfun.mu$inv.link(x%*%object$coefficients$mean)
      set.link(object$link,object$link.phi)$linkfun.mu$linkfun(mu_predict)
    }, precision = {
      set.link(object$link,object$link.phi)$linkfun.phi$inv.link(z%*%object$coefficients$precision)
    }, variance = {
      mu_predict=set.link(object$link,object$link.phi)$linkfun.mu$inv.link(x%*%object$coefficients$mean)
      phi_predict=set.link(object$link,object$link.phi)$linkfun.phi$inv.link(z%*%object$coefficients$precision)
      mu_predict*(1-mu_predict)/phi_predict
    }, quantile={
      mu_predict=set.link(object$link,object$link.phi)$linkfun.mu$inv.link(x%*%object$coefficients$mean)
      phi_predict=set.link(object$link,object$link.phi)$linkfun.phi$inv.link(z%*%object$coefficients$precision)
      qfun(at,mu_predict,phi_predict)
    })
    return(rval)
  }
}



# Cooks Distance
cooks.distance.robustbetareg=function(object,...)
{
  p=length(do.call("c",object$coefficients))
  linkobj=set.link(link.mu = object$link, link.phi = object$link.phi)
  y_hat=linkobj$linkfun.mu$inv.link(object$model$mean%*%object$coefficients$mean)
  MSE=as.numeric(t(object$y-y_hat)%*%(object$y-y_hat)/(object$n-p))
  D=NULL
  for(i in 1:object$n){
    fit.temp=robustbetareg(object$formula,data=object$data[-i,],alpha=object$Tuning)
    y_hat_temp=linkobj$linkfun.mu$inv.link(object$model$mean%*%fit.temp$coefficients$mean)
    D=c(D,t(y_hat-y_hat_temp)%*%(y_hat-y_hat_temp)/(MSE*p))
  }
  return(D)
}

# Hat matrix
hatvalues.robustbetareg=function(object)
{
  mu_hat=object$fitted.values$mu.predict
  phi_hat=object$fitted.values$phi.predict
  y=object$y
  X=object$model$mean
  linkobj=set.link(link.mu=object$link,link.phi=object$link.phi)
  d.link.mu=linkobj$linkfun.mu$d.linkfun(mu_hat)

  mu_star=digamma(mu_hat*phi_hat)-digamma((1-mu_hat)*phi_hat)
  V_star=trigamma(mu_hat*phi_hat)+trigamma((1-mu_hat)*phi_hat)
  W.PHI=diag(x=phi_hat*V_star*((d.link.mu)^(-2)))
  H=sqrt(W.PHI)%*%X%*%solve(t(X)%*%W.PHI%*%X)%*%t(X)%*%sqrt(W.PHI)
  return(diag(H))
}
